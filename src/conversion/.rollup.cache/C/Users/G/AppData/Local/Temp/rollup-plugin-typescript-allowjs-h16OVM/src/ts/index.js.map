{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../OneDrive/Documents/tests/bigint-buffer/src/conversion/src/ts/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,GAAG,MAAM,kBAAkB,CAAA;AASvC,MAAM,CAAC,IAAI,QAAQ,GAAG,KAAK,CAAA;AAC3B,IAAI,SAA6B,CAAA;AAEjC,MAAM,UAAU,GAAG,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,QAAQ,KAAK,WAAW,CAAA;AAE1F,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IACrB,IAAI,CAAC;QAEH,SAAS,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,eAAe,CAAC,CAAA;QAChD,QAAQ,GAAG,SAAS,KAAK,SAAS,CAAA;IACpC,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACX,OAAO,CAAC,IAAI,CAAC,8EAA8E,CAAC,CAAA;IAC9F,CAAC;AACH,CAAC;KAAM,CAAC;IAEN,SAAS,GAAG;QACV,QAAQ,EAAE,CAAC,GAAW,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC1E,UAAU,EAAE,CAAC,GAAW,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC;KAClE,CAAA;AACH,CAAC;AAOD,MAAM,UAAU,UAAU,CAAE,GAAW;IACrC,IAAI,OAAO,CAAC,OAAO,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;QAC/C,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QACjC,QAAQ,CAAC,OAAO,EAAE,CAAA;QAClB,MAAM,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;QACpC,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACrB,OAAO,MAAM,CAAC,CAAC,CAAC,CAAA;QAClB,CAAC;QACD,OAAO,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,CAAA;IAC3B,CAAC;IACD,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;AACvC,CAAC;AAED,MAAM,UAAU,oBAAoB;IAClC,IAAI,CAAC;QACH,MAAM,IAAI,GAAG,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAA;QAClD,OAAO,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,CAAA;IAC3B,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,KAAK,CAAA;IACd,CAAC;AACH,CAAC;AAOD,MAAM,UAAU,UAAU,CAAE,GAAW;IACrC,IAAI,OAAO,CAAC,OAAO,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;QAC/C,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;QAC/B,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACrB,OAAO,MAAM,CAAC,CAAC,CAAC,CAAA;QAClB,CAAC;QACD,OAAO,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,CAAA;IAC3B,CAAC;IACD,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;AACtC,CAAC;AAQD,MAAM,UAAU,UAAU,CAAE,GAAW,EAAE,KAAa;IACpD,IAAI,OAAO,CAAC,OAAO,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;QAC/C,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;QAC5B,MAAM,MAAM,GACR,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAA;QACxE,MAAM,CAAC,OAAO,EAAE,CAAA;QAChB,OAAO,MAAM,CAAA;IACf,CAAC;IAED,OAAO,SAAS,CAAC,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAA;AACpE,CAAC;AAQD,MAAM,UAAU,UAAU,CAAE,GAAW,EAAE,KAAa;IACpD,IAAI,OAAO,CAAC,OAAO,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;QAC/C,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAA;QAC5B,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAA;IAC7E,CAAC;IACD,OAAO,SAAS,CAAC,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAA;AACnE,CAAC;AAeD,MAAM,UAAU,QAAQ,CAAE,CAAS,EAAE,WAAoB,KAAK,EAAE,UAAmB;IACjF,MAAM,QAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAA;IAChD,IAAI,QAAQ,IAAI,IAAI,EAAE,CAAC;QACrB,MAAM,IAAI,UAAU,CAAC,wEAAwE,CAAC,CAAA;IAChG,CAAC;IACD,IAAI,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;IACrB,IAAI,UAAU,KAAK,SAAS,EAAE,CAAC;QAC7B,IAAI,UAAU,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAChC,MAAM,IAAI,UAAU,CAAC,wBAAwB,UAAU,4BAA4B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAA;QACjH,CAAC;QACD,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,EAAE,GAAG,CAAC,CAAA;IACzC,CAAC;IACD,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA;AACtC,CAAC;AAYD,MAAM,UAAU,WAAW,CAAE,CAAS,EAAE,oBAA6B,KAAK;IACxE,IAAI,CAAC,GAAG,CAAC;QAAE,MAAM,UAAU,CAAC,uEAAuE,CAAC,CAAA;IACpG,OAAO,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,iBAAiB,CAAC,CAAA;AACpD,CAAC;AAOD,MAAM,UAAU,WAAW,CAAE,GAAsC;IACjE,IAAI,IAAI,GAAG,EAAE,CAAA;IACb,IAAI,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC;QAAE,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAA;;QAChE,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAA;IAE9B,IAAI,GAAG,GAAG,EAAE,CAAA;IACZ,KAAK,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC;QAC/B,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;QACpB,GAAG,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE,CAAA;IAC1B,CAAC;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAYD,MAAM,UAAU,WAAW,CAAE,CAAS,EAAE,WAAoB,KAAK,EAAE,UAAmB;IACpF,IAAI,CAAC,GAAG,CAAC;QAAE,MAAM,UAAU,CAAC,uEAAuE,CAAC,CAAA;IACpG,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAA;AACvD,CAAC;AAWD,MAAM,UAAU,WAAW,CAAE,MAAc;IACzC,OAAO,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAA;AACvC,CAAC;AAWD,MAAM,UAAU,YAAY,CAAE,CAAS;IACrC,IAAI,CAAC,GAAG,CAAC;QAAE,MAAM,UAAU,CAAC,uEAAuE,CAAC,CAAA;IACpG,OAAO,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;AAC5C,CAAC;AASD,MAAM,UAAU,YAAY,CAAE,IAAY;IACxC,OAAO,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AAC/C,CAAC;AACD,SAAS,QAAQ,CAAE,KAAwC;IACzD,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC;QAAE,OAAO,KAAK,CAAA;IAExC,IAAI,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;QAC9B,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAA;IACtE,CAAC;IAED,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;QACjC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAA;IAC3C,CAAC;IAED,MAAM,IAAI,SAAS,CAAC,wCAAwC,CAAC,CAAA;AAC/D,CAAC;AAQD,MAAM,UAAU,SAAS,CAAE,GAAsC;IAC/D,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAA;IAC3B,IAAI,UAAU;QAAE,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAA;;QACjE,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,CAAA;AAC3C,CAAC;AAUD,MAAM,UAAU,SAAS,CAAE,GAAW,EAAE,oBAA6B,KAAK;IACxE,IAAI,CAAC,UAAU,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACtC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAA;IAC1D,CAAC;IACD,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAA;AAC7C,CAAC;AAWD,MAAM,UAAU,QAAQ,CAAE,GAAsC,EAAE,WAAoB,KAAK,EAAE,UAAmB;IAC9G,IAAI,UAAU,EAAE,CAAC;QACf,IAAI,CAAC,GAAG,EAAE,CAAA;QACV,MAAM,CAAC,GAAG,kBAAkB,CAAA;QAC5B,IAAI,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC;YAAE,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAA;;YAC/G,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;QAE9B,GAAkB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YAChC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAA;QAC5B,CAAC,CAAC,CAAA;QAEF,OAAO,QAAQ,CAAC,CAAC,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAA;IAC1C,CAAC;SAAM,CAAC;QACN,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAA;QAC3B,IAAI,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC;YAAE,GAAG,GAAG,IAAI,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAA;QAC9H,OAAO,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAA;IAC3E,CAAC;AACH,CAAC;AAYD,MAAM,UAAU,QAAQ,CAAE,MAAc,EAAE,oBAA6B,KAAK;IAC1E,IAAI,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAA;IAC1B,GAAG,GAAG,QAAQ,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAA;IACxD,IAAI,UAAU,EAAE,CAAC;QACf,OAAO,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,gBAAgB,CAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YAC5D,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAA;QACxB,CAAC,CAAC,CAAC,CAAC,MAAM,CAAA;IACZ,CAAC;SAAM,CAAC;QACN,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACjC,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;IAC1F,CAAC;AACH,CAAC;AAYD,MAAM,UAAU,cAAc,CAAE,CAAS,EAAE,UAAmB,KAAK,EAAE,UAAmB,IAAI;IAC1F,OAAO,GAAG,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,OAAO,CAAC,CAAA;AACrD,CAAC;AAOD,MAAM,UAAU,cAAc,CAAE,CAAS;IACvC,OAAO,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;AACnC,CAAC","sourcesContent":["import * as b64 from '@juanelas/base64'\n\ninterface ConverterInterface {\n  toBigInt: (buf: Buffer, bigEndian?: boolean) => bigint\n  fromBigInt: (num: bigint, buf: Buffer, bigEndian?: boolean) => Buffer\n}\n\ndeclare let process: { browser: boolean }\n\nexport let isNative = false\nlet converter: ConverterInterface\n\nconst IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined'\n\nif (!process.browser) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    converter = require('bindings')('bigint_buffer')\n    isNative = converter !== undefined\n  } catch (e) {\n    console.warn('bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)')\n  }\n} else {\n  // fallback to pure JS if needed\n  converter = {\n    toBigInt: (buf: Buffer) => BigInt('0x' + Buffer.from(buf).toString('hex')),\n    fromBigInt: (num: bigint) => Buffer.from(num.toString(16), 'hex')\n  }\n}\n\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\nexport function toBigIntLE (buf: Buffer): bigint {\n  if (process.browser || converter === undefined) {\n    const reversed = Buffer.from(buf)\n    reversed.reverse()\n    const hex = reversed.toString('hex')\n    if (hex.length === 0) {\n      return BigInt(0)\n    }\n    return BigInt(`0x${hex}`)\n  }\n  return converter.toBigInt(buf, false)\n}\n\nexport function validateBigIntBuffer (): boolean {\n  try {\n    const test = toBigIntLE(Buffer.from([0x01, 0x00]))\n    return test === BigInt(1)\n  } catch {\n    return false\n  }\n}\n\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\nexport function toBigIntBE (buf: Buffer): bigint {\n  if (process.browser || converter === undefined) {\n    const hex = buf.toString('hex')\n    if (hex.length === 0) {\n      return BigInt(0)\n    }\n    return BigInt(`0x${hex}`)\n  }\n  return converter.toBigInt(buf, true)\n}\n\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\nexport function toBufferLE (num: bigint, width: number): Buffer {\n  if (process.browser || converter === undefined) {\n    const hex = num.toString(16)\n    const buffer =\n        Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex')\n    buffer.reverse()\n    return buffer\n  }\n  // Allocation is done here, since it is slower using napi in C\n  return converter.fromBigInt(num, Buffer.allocUnsafe(width), false)\n}\n\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\nexport function toBufferBE (num: bigint, width: number): Buffer {\n  if (process.browser || converter === undefined) {\n    const hex = num.toString(16)\n    return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex')\n  }\n  return converter.fromBigInt(num, Buffer.allocUnsafe(width), true)\n}\n\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Parses a hexadecimal string for correctness and returns it with or without '0x' prefix, and/or with the specified byte length\n * @param a - the string with an hexadecimal number to be parsed\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n * @throws {@link RangeError} if requested byte length is less than the input byte length\n */\nexport function parseHex (a: string, prefix0x: boolean = false, byteLength?: number): string {\n  const hexMatch = a.match(/^(0x)?([\\da-fA-F]+)$/)\n  if (hexMatch == null) {\n    throw new RangeError('input must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'')\n  }\n  let hex = hexMatch[2]\n  if (byteLength !== undefined) {\n    if (byteLength < hex.length / 2) {\n      throw new RangeError(`expected byte length ${byteLength} < input hex byte length ${Math.ceil(hex.length / 2)}`)\n    }\n    hex = hex.padStart(byteLength * 2, '0')\n  }\n  return (prefix0x) ? '0x' + hex : hex\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {@link RangeError} if a < 0.\n */\nexport function bigintToBuf (a: bigint, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return hexToBuf(bigintToHex(a), returnArrayBuffer)\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\nexport function bufToBigint (buf: ArrayBuffer | TypedArray | Buffer): bigint {\n  let bits = 8n\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8)\n  else buf = new Uint8Array(buf)\n\n  let ret = 0n\n  for (const i of (buf).values()) {\n    const bi = BigInt(i)\n    ret = (ret << bits) + bi\n  }\n  return ret\n}\n\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {@link RangeError} if a < 0\n */\nexport function bigintToHex (a: bigint, prefix0x: boolean = false, byteLength?: number): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return parseHex(a.toString(16), prefix0x, byteLength)\n}\n\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n */\nexport function hexToBigint (hexStr: string): bigint {\n  return BigInt(parseHex(hexStr, true))\n}\n\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {@link RangeError} if a < 0.\n */\nexport function bigintToText (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return bufToText(hexToBuf(a.toString(16)))\n}\n\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\nexport function textToBigint (text: string): bigint {\n  return hexToBigint(bufToHex(textToBuf(text)))\n}\nfunction toBuffer (input: ArrayBuffer | TypedArray | Buffer): Buffer {\n  if (Buffer.isBuffer(input)) return input\n\n  if (ArrayBuffer.isView(input)) {\n    return Buffer.from(input.buffer, input.byteOffset, input.byteLength)\n  }\n\n  if (input instanceof ArrayBuffer) {\n    return Buffer.from(new Uint8Array(input))\n  }\n\n  throw new TypeError('Unsupported input type for Buffer.from')\n}\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\nexport function bufToText (buf: ArrayBuffer | TypedArray | Buffer): string {\n  const input = toBuffer(buf)\n  if (IS_BROWSER) return new TextDecoder().decode(new Uint8Array(input))\n  else return Buffer.from(input).toString()\n}\n\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\nexport function textToBuf (str: string, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  if (!IS_BROWSER && !returnArrayBuffer) {\n    return Buffer.from(new TextEncoder().encode(str).buffer)\n  }\n  return new TextEncoder().encode(str).buffer\n}\n\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n * @param prefix0x - set to true to prefix the output with '0x'\n * @param byteLength - pad the output to have the desired byte length. Notice that the hex length is double the byte length.\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\nexport function bufToHex (buf: ArrayBuffer | TypedArray | Buffer, prefix0x: boolean = false, byteLength?: number): string {\n  if (IS_BROWSER) {\n    let s = ''\n    const h = '0123456789abcdef'\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    else buf = new Uint8Array(buf);\n\n    (buf as Uint8Array).forEach((v) => {\n      s += h[v >> 4] + h[v & 15]\n    })\n\n    return parseHex(s, prefix0x, byteLength)\n  } else {\n    const input = toBuffer(buf)\n    if (ArrayBuffer.isView(input)) buf = new Uint8Array(input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength))\n    return parseHex(Buffer.from(input).toString('hex'), prefix0x, byteLength)\n  }\n}\n\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {@link RangeError} if input string does not hold an hexadecimal number\n */\nexport function hexToBuf (hexStr: string, returnArrayBuffer: boolean = false): ArrayBuffer | Buffer {\n  let hex = parseHex(hexStr)\n  hex = parseHex(hexStr, false, Math.ceil(hex.length / 2)) // pad to have a length in bytes\n  if (IS_BROWSER) {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g)!.map((h) => { // eslint-disable-line\n      return parseInt(h, 16)\n    })).buffer\n  } else {\n    const b = Buffer.from(hex, 'hex')\n    return returnArrayBuffer ? b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength) : b\n  }\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToBase64 (a: bigint, urlsafe: boolean = false, padding: boolean = true): string {\n  return b64.encode(bigintToBuf(a), urlsafe, padding)\n}\n\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\nexport function base64ToBigint (a: string): bigint {\n  return bufToBigint(b64.decode(a))\n}\n"]}